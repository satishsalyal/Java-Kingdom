># Nested try and Multiple catch Clauses

## Nested try Statements

The try statement can be nested. That is, a try statement can be inside the block of another try. Each time a try statement is entered, the context of that exception is pushed on the stack. If an inner try statement does not have a catch handler for a particular exception, the stack is unwound and the next try statement’s catch handlers are inspected for a match. This continues until one of the catch statements succeeds, or until all of the nested try statements are exhausted. If no catch statement matches, then the Java run-time system will handle the exception.

##### [Example 01](../20-Examples/13-Exception-Handling/03-Nested-try-and-Mutiple-catch-Clauses/Example-01/)

```java
// An example of nested try statements.
class NestTry {
    public static void main(String args[]) {
        try {
            int a = args.length;
            /* If no command-line args are present,
            the following statement will generate
            a divide-by-zero exception. */
            int b = 42 / a;
            System.out.println("a = " + a);
            try { // nested try block
                /* If one command-line arg is used,
                then a divide-by-zero exception
                will be generated by the following code. */
                if(a==1)
                    a = a/(a-a); // division by zero
                /* If two command-line args are used,
                then generate an out-of-bounds exception. */
                if(a==2) {
                    int c[] = { 1 };
                    c[42] = 99; // generate an out-of-bounds exception
                }
            } catch(ArrayIndexOutOfBoundsException e) {
                System.out.println("Array index out-of-bounds: " + e);
            }
        } catch(ArithmeticException e) {
            System.out.println("Divide by 0: " + e);
        }
    }
}
```

The program works as follows. When you execute the program with no command-line arguments, a divide-byzero exception is generated by the outer `try` block. Execution of the program with one command-line argument generates a divide-by-zero exception from within the nested `try` block. Since the inner block does not `catch` this exception, it is passed on to the outer `try` block, where it is handled. If you execute the program with two command-line arguments, an array boundary exception is generated from within the inner `try` block. Here are sample
runs that illustrate each case:

##### Sample Runs
    C:\>java NestTry
    Divide by 0: java.lang.ArithmeticException: / by zero

    C:\>java NestTry One
    a = 1
    Divide by 0: java.lang.ArithmeticException: / by zero
    
    C:\>java NestTry One Two
    a = 2
    Array index out-of-bounds:
        java.lang.ArrayIndexOutOfBoundsException:42


Nesting of `try` statements can occur in less obvious ways when method calls are involved. For example, you can enclose a call to a method within a `try` block. Inside that method is another `try` statement. In this case, the `try` within the method is still nested inside the outer `try` block, which calls the method. Here is the previous program recoded so that the nested `try` block is moved inside the method `nesttry()`:

##### [Example 02](../20-Examples/13-Exception-Handling/03-Nested-try-and-Mutiple-catch-Clauses/Example-02/)
```java
/* Try statements can be implicitly nested via
calls to methods. */
class MethNestTry {
    static void nesttry(int a) {
        try { // nested try block
            /* If one command-line arg is used,
            then a divide-by-zero exception
            will be generated by the following code. */
            if(a==1)
                a = a/(a-a); // division by zero
            /* If two command-line args are used,
            then generate an out-of-bounds exception. */
            if(a==2) {
                int c[] = { 1 };
                c[42] = 99; // generate an out-of-bounds exception
            }
        } catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index out-of-bounds: " + e);
        }
    }
    public static void main(String args[]) {
        try {
            int a = args.length;
            /* If no command-line args are present,
            the following statement will generate
            a divide-by-zero exception. */
            int b = 42 / a;
            System.out.println("a = " + a);
            nesttry(a);
        } catch(ArithmeticException e) {
            System.out.println("Divide by 0: " + e);
        }
    }
}
```

The output of this program is identical to that of the preceding example.

## Multiple catch Clauses

A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following −

```java
try {
   // Protected code
} catch (ExceptionType1 e1) {
   // Catch block
} catch (ExceptionType2 e2) {
   // Catch block
} catch (ExceptionType3 e3) {
   // Catch block
}
```

The previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.

##### [Example 03](../20-Examples/13-Exception-Handling/03-Nested-try-and-Mutiple-catch-Clauses/Example-03/)

```java
// Demonstrate multiple catch statements.
class MultipleCatches {
    public static void main(String args[]) {
        try {
            int a = args.length;
            System.out.println("a = " + a);
            int b = 42 / a;
            int c[] = { 1 };
            c[42] = 99;
        } catch(ArithmeticException e) {
            System.out.println("Divide by 0: " + e);
        } catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index oob: " + e);
        }
        System.out.println("After try/catch blocks.");
    }
}
```

This program will cause a division-by-zero exception if it is started with no commandline arguments, since a will equal zero. It will survive the division if you provide a command-line argument, setting a to something larger than zero. But it will cause an `ArrayIndexOutOfBoundsException`, since the `int` array `c` has a length of 1, yet the program attempts to assign a value to `c[42]`.

##### Sample Runs
    C:\>java MultipleCatches
    a = 0
    Divide by 0: java.lang.ArithmeticException: / by zero
    After try/catch blocks.

    C:\>java MultipleCatches TestArg
    a = 1
    Array index oob: java.lang.ArrayIndexOutOfBoundsException:42
    After try/catch blocks.


When you use multiple catch statements, it is important to remember that exception subclasses must come before any of their superclasses. This is because a catch statement that uses a superclass will catch exceptions of that type plus any of its subclasses. Thus, a subclass would never be reached if it came after its superclass. Further, in Java, unreachable code is an error.

## External Resources

### Readings

* [Oracle Tutorials](https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html)
* [JavaTPoint - Multiple catch Clauses](https://www.javatpoint.com/multiple-catch-block-in-java)
* [JavaTPoint - Nested try](https://www.javatpoint.com/nested-try-block)

### Youtube Videos

* [Cave of Programming](https://www.youtube.com/watch?v=odhReeuuCXo&list=PL9DF6E4B45C36D411&index=36)

#### More Examples and Practice Questions

Provided in the last chapter of this section